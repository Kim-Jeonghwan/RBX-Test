/**********************************************************************

	Nexcom Co., Ltd.
	Copyright 2021. All Rights Reserved.

	Filename		: DevSci.c
	Version			: 00.01
	Description		: 
	Tracebility		: 
	Programmer	: 
	Last Updated	: 2025. 08. 04.

	Function List	:	
						

**********************************************************************/

/*
 * Modification History
 * --------------------
 * 
 * 
*/


/* DESCRIPTION
 * 
 * 
*/


/* ************************** [[   include  ]]  *********************************************************** */
#include "DevSci.h"

/* ************************** [[   define   ]]  *********************************************************** */
#define DCE_GPIO_PIN_SCIB_RXD     43u             // GPIO number for SCI RX
#define DCE_GPIO_PIN_SCIB_TXD     43u             // GPIO number for SCI TX
#define DCE_GPIO_CFG_SCIB_RXD     GPIO_43_SCIA_RX	// "pinConfig" for SCI RX
#define DCE_GPIO_CFG_SCIB_TXD     GPIO_42_SCIA_TX	// "pinConfig" for SCI TX


/* ************************** [[   global   ]]  *********************************************************** */
stSciFrame		xRcvScia;

static stQsci	xQScib;


/* ************************** [[  function  ]]  *********************************************************** */
/*
@funtion	void Initial_SCI(void)
@brief		
@param		void
@return		void
@remark	
	-	
*/
void Initial_SCI(void)
{
	Init_Scib_DCE();
	//InitialScib();	// CAN B를 같이 사용할 경우 
	//InitialScic();	// CAN C를 같이 사용할 경우 
	//InitialScid();	// CAN D를 같이 사용할 경우 

	memset(&xRcvScia, 0u, sizeof(xRcvScia));
}


/*
@funtion	static void Init_Scib_DCE(void)
@brief		
@param		void
@return		static void
@remark	
	-	
*/
static void Init_Scib_DCE(void)
{
	//
	// Initialize the Device Peripherals:
	//

	//
	// GPIO55 is the SCI Rx pin.
	//
	GPIO_setControllerCore(DCE_GPIO_PIN_SCIB_RXD, GPIO_CORE_CPU1);
	GPIO_setPinConfig(DCE_GPIO_CFG_SCIB_RXD);
	GPIO_setDirectionMode(DCE_GPIO_PIN_SCIB_RXD, GPIO_DIR_MODE_IN);
	GPIO_setPadConfig(DCE_GPIO_PIN_SCIB_RXD, GPIO_PIN_TYPE_STD);
	GPIO_setQualificationMode(DCE_GPIO_PIN_SCIB_RXD, GPIO_QUAL_ASYNC);

	//
	// GPIO54 is the SCI Tx pin.
	//
	GPIO_setControllerCore(DCE_GPIO_PIN_SCIB_TXD, GPIO_CORE_CPU1);
	GPIO_setPinConfig(DCE_GPIO_CFG_SCIB_TXD);
	GPIO_setDirectionMode(DCE_GPIO_PIN_SCIB_TXD, GPIO_DIR_MODE_OUT);
	GPIO_setPadConfig(DCE_GPIO_PIN_SCIB_TXD, GPIO_PIN_TYPE_STD);
	GPIO_setQualificationMode(DCE_GPIO_PIN_SCIB_TXD, GPIO_QUAL_ASYNC);


	//
	// Interrupts that are used in this example are re-mapped to
	// ISR functions found within this file.
	//
	Interrupt_register(INT_SCIA_RX, isr_scib_DCE);

	Interrupt_enable(INT_SCIA_RX);
	
	Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP9);


    //
    // 8 char bits, 1 stop bit, no parity. Baud rate is 115200.
    //
    SCI_setConfig(SCIA_BASE, DEVICE_LSPCLK_FREQ, 115200, (SCI_CONFIG_WLEN_8 |
                                                        SCI_CONFIG_STOP_ONE |
                                                        SCI_CONFIG_PAR_NONE));
    SCI_enableModule(SCIA_BASE);
    SCI_resetChannels(SCIA_BASE);
    SCI_enableFIFO(SCIA_BASE);

    //
    // RX and TX FIFO Interrupts Enabled
    //
    //SCI_enableInterrupt(SCIA_BASE, (SCI_INT_RXFF | SCI_INT_TXFF));
    SCI_enableInterrupt(SCIA_BASE, SCI_INT_RXFF);
    SCI_disableInterrupt(SCIA_BASE, SCI_INT_RXERR);

    //
    // The transmit FIFO generates an interrupt when FIFO status
    // bits are less than or equal to 2 out of 16 words
    // The receive FIFO generates an interrupt when FIFO status
    // bits are greater than equal to 2 out of 16 words
    //
    SCI_setFIFOInterruptLevel(SCIA_BASE, SCI_FIFO_TX1, SCI_FIFO_RX1);
    SCI_performSoftwareReset(SCIA_BASE);

    SCI_resetTxFIFO(SCIA_BASE);
    SCI_resetRxFIFO(SCIA_BASE);

}




/*
@funtion	static interrupt void isr_scib_DCE(void)
@brief		
@param		void
@return		[ static interrupt void ]	
@remark	
	-	
*/
static interrupt void isr_scib_DCE(void)
{
    Uint16 Data[1u];

    SCI_readCharArray(SCIA_BASE, Data, 1u);

  	switch(xRcvScia.Frame)
  	{
  	case eSCIA_SOF:
  		if(Data[0] == 0x7Eu)
  		{
  			xRcvScia.Frame	= eSCIA_MSGID;
  			xRcvScia.POS	= 0u;
  			xRcvScia.CRC	= 0u;
  		}
  	break;

  	case eSCIA_MSGID:
		xRcvScia.Frame	= eSCIA_LEN;
		xRcvScia.MSGID	= Data[0u];
  	break;

  	case eSCIA_LEN:
		xRcvScia.Frame	= eSCIA_DATA;
		xRcvScia.LEN	= Data[0u];
		xRcvScia.CRC	+= Data[0u];
  	break;

  	case eSCIA_DATA:
		xRcvScia.DATA[xRcvScia.POS++] = Data[0u];
		xRcvScia.CRC += Data[0u];
		xRcvScia.LEN--;

		if(xRcvScia.LEN == 0u)
		{
			xRcvScia.Frame	= eSCIA_CRC;
		}
  	break;

  	case eSCIA_CRC:
  		if((xRcvScia.CRC & 0xFFu) == Data[0u])
  		{
			xRcvScia.Frame	= eSCIA_EOT;
		}
		else
		{
			xRcvScia.Frame	= eSCIA_SOF;
		}
  	break;  	

  	case eSCIA_EOT:
		xRcvScia.Frame	= eSCIA_SOF;

		rcvSciaPacket(xRcvScia.MSGID, xRcvScia.DATA);
  	break;  	
  	
  	default:
  		// MISRA
  	break;
  	}

    SCI_clearOverflowStatus(SCIA_BASE);

    SCI_clearInterruptStatus(SCIA_BASE, SCI_INT_RXFF);

    //
    // Issue PIE ack
    //
    Interrupt_clearACKGroup(INTERRUPT_ACK_GROUP9);

}




/*
@funtion	void xmtScib_DCE(Uint16 data[], Uint16 len)
@brief		
@param		[ Uint16 data[] ]	
@param		[ Uint16 len ]	
@return		void
@remark	
	-	
*/
void xmtScib_DCE(Uint16 data[], Uint16 len)
{
	Uint16 i = 0u;

	for(i = 0u; i < len; i++)
	{
	    enqueueSci(&xQScib, data[i]);
	}


	//SCI_writeCharArray(SCIB_BASE, data, len);
}



/*
@funtion	void sendScib_DCE(void)
@brief		100 us 주기로 전송 
@param		void
@return		void
@remark	
	-	ref isr_CpuTimer0()
*/
void sendScib_DCE(void)
{
    Uint16 i = 0u;
    Uint16 len = 0u;
    Uint16 popData = 0u;
    Uint16 sendData[10u] = {0u};

    for(i = 0u; i < 10u; i++)
    {
        if(dequeueSci(&xQScib, &popData) == 1u)
        {
            sendData[len ++] = popData;
        }
    }

    if(len > 0u)
    {
        SCI_writeCharArray(SCIB_BASE, sendData, len);
    }
}





/*
@funtion	static void enqueueSci(stQsci *pstQ, Uint16 Data)
@brief		
@param		[ stQsci *pstQ ]	
@param		[ Uint16 Data ]	
@return		static void
@remark	
	-	
*/
static void enqueueSci(stQsci *pstQ, Uint16 Data)
{
    Uint16 nRear = 0u;

    if(pstQ->rear <= QUEUE_MAX_SCI)
    {
        nRear = ((pstQ->rear + 1u) % QUEUE_MAX_SCI);
    }

    if(nRear != pstQ->front)
    {
        pstQ->Data[pstQ->rear]  = Data;
        pstQ->rear           	= nRear;
    }
}




/*
@funtion	static Uint16 dequeueSci(stQsci *pstQ, Uint16 *pData)
@brief		
@param		[ stQsci *pstQ ]	
@param		[ Uint16 *pData ]	
@return		[ static Uint16 ]	
@remark	
	-	
*/
static Uint16 dequeueSci(stQsci *pstQ, Uint16 *pData)
{
    Uint16 result = 0u;

    if(pstQ->front != pstQ->rear)
    {
        *pData = pstQ->Data[pstQ->front];

        if(pstQ->front <= QUEUE_MAX_SCI)
        {
            pstQ->front = (pstQ->front + 1u) % QUEUE_MAX_SCI;
        }

        result = 1u;
    }

    return result;
}


