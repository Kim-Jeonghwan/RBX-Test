/**********************************************************************

	Nexcom Co., Ltd.
	Copyright 2021. All Rights Reserved.

	Filename		: CSU_LED.c
	Version			: 00.01
	Description		: 
	Tracebility		: 
	Programmer	: 
	Last Updated	: 2025. 08. 05.

	Function List	:	
						

**********************************************************************/

/*
 * Modification History
 * --------------------
 * 
 * 
*/


/* DESCRIPTION
 * 
 * 
*/


/* ************************** [[   include  ]]  *********************************************************** */
#include "CSU_LED.h"

/* ************************** [[   define   ]]  *********************************************************** */


/* ************************** [[   global   ]]  *********************************************************** */
stLedStatus xLed;

/* ************************** [[  function  ]]  *********************************************************** */

/*
@funtion	void initLedRegister(void)
@brief		
@param		void
@return		void
@remark	
	-	
*/
void initLedRegister(void)
{
	xLed.pwrMain.IndexG 		= eLED_POWER_MAIN_G;
	xLed.pwrMain.IndexR			= eLED_POWER_MAIN_R;
	xLed.pwrDriving.IndexG 		= eLED_POWER_DRIVING_G;
	xLed.pwrDriving.IndexR 		= eLED_POWER_DRIVING_R;
	xLed.pwrWarnLamp.IndexG 	= eLED_POWER_WARN_LAMP_G;
	xLed.pwrWarnLamp.IndexR 	= eLED_POWER_WARN_LAMP_R;
	xLed.opRemote.IndexG 		= eLED_REMOTE_G;
	xLed.opRemote.IndexR 		= eLED_REMOTE_R;
	xLed.opLocal.IndexG 		= eLED_LOCAL_G;
	xLed.opLocal.IndexR 		= eLED_LOCAL_R;
	xLed.opElevation.IndexG 	= eLED_ELEVATION_G;
	xLed.opElevation.IndexR 	= eLED_ELEVATION_R;
	xLed.opAzimuth.IndexG 		= eLED_AZIMUTH_G;
	xLed.opAzimuth.IndexR 		= eLED_AZIMUTH_R;
	xLed.stsComm.IndexG 		= eLED_STATUS_COMM_G;
	xLed.stsComm.IndexR 		= eLED_STATUS_COMM_R;
	xLed.stsCb.IndexG 			= eLED_STATUS_CB_G;
	xLed.stsCb.IndexR 			= eLED_STATUS_CB_R;
	xLed.stsIncl.IndexG 		= eLED_STATUS_INCL_G;
	xLed.stsIncl.IndexR 		= eLED_STATUS_INCL_R;
	xLed.stsDrivingPower.IndexG = eLED_STATUS_DRIVING_POWER_G;
	xLed.stsDrivingPower.IndexR = eLED_STATUS_DRIVING_POWER_R;
	xLed.stsElMotor.IndexG 		= eLED_STATUS_EL_MOTOR_G;
	xLed.stsElMotor.IndexR 		= eLED_STATUS_EL_MOTOR_R;
	xLed.stsAzMotor.IndexG 		= eLED_STATUS_AZ_MOTOR_G;
	xLed.stsAzMotor.IndexR 		= eLED_STATUS_AZ_MOTOR_R;
	xLed.stsElSensor.IndexG 	= eLED_STATUS_EL_SENSOR_G;
	xLed.stsElSensor.IndexR 	= eLED_STATUS_EL_SENSOR_R;
	xLed.stsAzSensor.IndexG 	= eLED_STATUS_AZ_SENSOR_G;
	xLed.stsAzSensor.IndexR 	= eLED_STATUS_AZ_SENSOR_R;
	xLed.stsElBrake.IndexG 		= eLED_STATUS_EL_BRAKE_G;
	xLed.stsElBrake.IndexR 		= eLED_STATUS_EL_BRAKE_R;
	xLed.stsAzBrake.IndexG 		= eLED_STATUS_AZ_BRAKE_G;
	xLed.stsAzBrake.IndexR 		= eLED_STATUS_AZ_BRAKE_R;
	xLed.stsElLimit.IndexG 		= eLED_STATUS_EL_LIMIT_G;
	xLed.stsElLimit.IndexR 		= eLED_STATUS_EL_LIMIT_R;
	xLed.stsMlLimit.IndexG 		= eLED_STATUS_ML_LIMIT_G;
	xLed.stsMlLimit.IndexR 		= eLED_STATUS_ML_LIMIT_R;
	xLed.stsAntLock1.IndexG 	= eLED_STATUS_ANT_LOCK1_G;
	xLed.stsAntLock1.IndexR 	= eLED_STATUS_ANT_LOCK1_R;
	xLed.stsAntLock2.IndexG 	= eLED_STATUS_ANT_LOCK2_G;
	xLed.stsAntLock2.IndexR 	= eLED_STATUS_ANT_LOCK2_R;
	xLed.setDriving.IndexG 		= eLED_SETUP_DRIVING_G;
	xLed.setDriving.IndexR 		= eLED_SETUP_DRIVING_R;
	xLed.setDone.IndexG 		= eLED_SETUP_DONE_G;
	xLed.setDone.IndexR 		= eLED_SETUP_DONE_R;
}



void updateLedState(void)
{
	Uint16 i = 0u;
	stLed *pItem = &xLed.pwrMain;
	Uint16 cnt = sizeof(stLedStatus) / sizeof(stLed);

	for(i = 0u; i < cnt; i ++)
	{
		setLedState(pItem);
		pItem ++;
	}
}


/*
@funtion	static void setLedState(stLed *pLed)
@brief		
@param		[ stLed *pLed ]	
@return		void
@remark	
	-	
*/
static void setLedState(stLed *pLed)
{
	if(pLed->Color == LED_GREEN)
	{
		// GREEN
		if(pLed->Toggle == LED_TOGGLE)
		{
			if(pLed->Temp == 0u)
			{
				setLedToggle(pLed->IndexG);

				pLed->Temp = pLed->Time;
			}
			else
			{
				pLed->Temp --;
			}
		}
		else
		{
			setLedEnable(pLed->IndexG, pLed->State);
		}
		
		setLedEnable(pLed->IndexR, LED_OFF);
	}
	else
	{
		// RED
		if(pLed->Toggle == LED_TOGGLE)
		{
			if(pLed->Temp == 0u)
			{
				setLedToggle(pLed->IndexR);

				pLed->Temp = pLed->Time;
			}
			else
			{
				pLed->Temp --;
			}
		}
		else
		{
			setLedEnable(pLed->IndexR, pLed->State);
		}		

		setLedEnable(pLed->IndexG, LED_OFF);
	}
}





/*
@funtion	void static setLedEnable(Uint16 Index, Uint16 State)
@brief		
@param		[ Uint16 Index ]	
@param		[ Uint16 State ]	
@return		void
@remark	
	-	
*/
static void setLedEnable(Uint16 Index, Uint16 State)
{
	switch(Index)
	{
	case eLED_POWER_MAIN_G:
		GpioDataRegs.GPADAT.bit.GPIO3 = State;
	break;

	case eLED_POWER_MAIN_R:
		GpioDataRegs.GPCDAT.bit.GPIO68 = State;
	break;

	case eLED_POWER_DRIVING_G:
		GpioDataRegs.GPADAT.bit.GPIO4 = State;
	break;

	case eLED_POWER_DRIVING_R:
		GpioDataRegs.GPCDAT.bit.GPIO69 = State;
	break;

	case eLED_POWER_WARN_LAMP_G:
		GpioDataRegs.GPADAT.bit.GPIO5 = State;
	break;

	case eLED_POWER_WARN_LAMP_R:
		GpioDataRegs.GPCDAT.bit.GPIO70 = State;
	break;

	case eLED_REMOTE_G:
		GpioDataRegs.GPADAT.bit.GPIO6 = State;
	break;

	case eLED_REMOTE_R:
		GpioDataRegs.GPCDAT.bit.GPIO71 = State;
	break;

	case eLED_LOCAL_G:
		GpioDataRegs.GPADAT.bit.GPIO7 = State;
	break;

	case eLED_LOCAL_R:
		GpioDataRegs.GPCDAT.bit.GPIO73 = State;
	break;

	case eLED_ELEVATION_G:
		GpioDataRegs.GPADAT.bit.GPIO8 = State;
	break;

	case eLED_ELEVATION_R:
		GpioDataRegs.GPCDAT.bit.GPIO74 = State;
	break;

	case eLED_AZIMUTH_G:
		GpioDataRegs.GPADAT.bit.GPIO9 = State;
	break;

	case eLED_AZIMUTH_R:
		GpioDataRegs.GPCDAT.bit.GPIO75 = State;
	break;

	case eLED_STATUS_COMM_G:
		GpioDataRegs.GPADAT.bit.GPIO13 = State;
	break;

	case eLED_STATUS_COMM_R:
		GpioDataRegs.GPCDAT.bit.GPIO78 = State;
	break;

	case eLED_STATUS_CB_G:
		GpioDataRegs.GPADAT.bit.GPIO14 = State;
	break;

	case eLED_STATUS_CB_R:
		GpioDataRegs.GPCDAT.bit.GPIO79 = State;
	break;

	case eLED_STATUS_INCL_G:
		GpioDataRegs.GPADAT.bit.GPIO15 = State;
	break;

	case eLED_STATUS_INCL_R:
		GpioDataRegs.GPCDAT.bit.GPIO80 = State;
	break;

	case eLED_STATUS_DRIVING_POWER_G:
		GpioDataRegs.GPADAT.bit.GPIO16 = State;
	break;

	case eLED_STATUS_DRIVING_POWER_R:
		GpioDataRegs.GPCDAT.bit.GPIO81 = State;
	break;

	case eLED_STATUS_EL_MOTOR_G:
		GpioDataRegs.GPADAT.bit.GPIO17 = State;
	break;

	case eLED_STATUS_EL_MOTOR_R:
		GpioDataRegs.GPCDAT.bit.GPIO82 = State;
	break;

	case eLED_STATUS_AZ_MOTOR_G:
		GpioDataRegs.GPADAT.bit.GPIO18 = State;
	break;

	case eLED_STATUS_AZ_MOTOR_R:
		GpioDataRegs.GPCDAT.bit.GPIO83 = State;
	break;

	case eLED_STATUS_EL_SENSOR_G:
		GpioDataRegs.GPADAT.bit.GPIO19 = State;
	break;

	case eLED_STATUS_EL_SENSOR_R:
		GpioDataRegs.GPCDAT.bit.GPIO85 = State;
	break;

	case eLED_STATUS_AZ_SENSOR_G:
		GpioDataRegs.GPADAT.bit.GPIO20 = State;
	break;

	case eLED_STATUS_AZ_SENSOR_R:
		GpioDataRegs.GPCDAT.bit.GPIO86 = State;
	break;

	case eLED_STATUS_EL_BRAKE_G:
		GpioDataRegs.GPADAT.bit.GPIO21 = State;
	break;

	case eLED_STATUS_EL_BRAKE_R:
		GpioDataRegs.GPCDAT.bit.GPIO87 = State;
	break;

	case eLED_STATUS_AZ_BRAKE_G:
		GpioDataRegs.GPADAT.bit.GPIO22 = State;
	break;

	case eLED_STATUS_AZ_BRAKE_R:
		GpioDataRegs.GPCDAT.bit.GPIO88 = State;
	break;

	case eLED_STATUS_EL_LIMIT_G:
		GpioDataRegs.GPADAT.bit.GPIO23 = State;
	break;

	case eLED_STATUS_EL_LIMIT_R:
		GpioDataRegs.GPCDAT.bit.GPIO89 = State;
	break;

	case eLED_STATUS_ML_LIMIT_G:
		GpioDataRegs.GPADAT.bit.GPIO24 = State;
	break;

	case eLED_STATUS_ML_LIMIT_R:
		GpioDataRegs.GPCDAT.bit.GPIO91 = State;
	break;

	case eLED_STATUS_ANT_LOCK1_G:
		//GpioDataRegs.GPADAT.bit.GPIO25 = State;
		GpioDataRegs.GPBDAT.bit.GPIO34 = State;
	break;

	case eLED_STATUS_ANT_LOCK1_R:
		//GpioDataRegs.GPCDAT.bit.GPIO92 = State;
		GpioDataRegs.GPBDAT.bit.GPIO37 = State;
	break;

	case eLED_STATUS_ANT_LOCK2_G:
		GpioDataRegs.GPADAT.bit.GPIO26 = State;
	break;

	case eLED_STATUS_ANT_LOCK2_R:
		GpioDataRegs.GPCDAT.bit.GPIO93 = State;
	break;

	case eLED_SETUP_DRIVING_G:
		GpioDataRegs.GPADAT.bit.GPIO10 = State;
	break;

	case eLED_SETUP_DRIVING_R:
		GpioDataRegs.GPCDAT.bit.GPIO76 = State;
	break;

	case eLED_SETUP_DONE_G:
		GpioDataRegs.GPADAT.bit.GPIO11 = State;
	break;

	case eLED_SETUP_DONE_R:
		GpioDataRegs.GPCDAT.bit.GPIO77 = State;
	break;
	
	default:
		// MISRA
	break;
	}
}




/*
@funtion	void static setLedToggle(Uint16 Index)
@brief		
@param		[ Uint16 Index ]	
@return		void
@remark	
	-	
*/
static void setLedToggle(Uint16 Index)
{
	switch(Index)
	{
	case eLED_POWER_MAIN_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO3 = 1u;
	break;

	case eLED_POWER_MAIN_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO68 = 1u;
	break;

	case eLED_POWER_DRIVING_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO4 = 1u;
	break;

	case eLED_POWER_DRIVING_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO69 = 1u;
	break;

	case eLED_POWER_WARN_LAMP_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO5 = 1u;
	break;

	case eLED_POWER_WARN_LAMP_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO70 = 1u;
	break;

	case eLED_REMOTE_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO6 = 1u;
	break;

	case eLED_REMOTE_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO71 = 1u;
	break;

	case eLED_LOCAL_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO7 = 1u;
	break;

	case eLED_LOCAL_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO73 = 1u;
	break;

	case eLED_ELEVATION_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO8 = 1u;
	break;

	case eLED_ELEVATION_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO74 = 1u;
	break;

	case eLED_AZIMUTH_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO9 = 1u;
	break;

	case eLED_AZIMUTH_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO75 = 1u;
	break;

	case eLED_STATUS_COMM_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO13 = 1u;
	break;

	case eLED_STATUS_COMM_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO78 = 1u;
	break;

	case eLED_STATUS_CB_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO14 = 1u;
	break;

	case eLED_STATUS_CB_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO79 = 1u;
	break;

	case eLED_STATUS_INCL_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO15 = 1u;
	break;

	case eLED_STATUS_INCL_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO80 = 1u;
	break;

	case eLED_STATUS_DRIVING_POWER_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO16 = 1u;
	break;

	case eLED_STATUS_DRIVING_POWER_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO81 = 1u;
	break;

	case eLED_STATUS_EL_MOTOR_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO17 = 1u;
	break;

	case eLED_STATUS_EL_MOTOR_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO82 = 1u;
	break;

	case eLED_STATUS_AZ_MOTOR_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO18 = 1u;
	break;

	case eLED_STATUS_AZ_MOTOR_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO83 = 1u;
	break;

	case eLED_STATUS_EL_SENSOR_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO19 = 1u;
	break;

	case eLED_STATUS_EL_SENSOR_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO85 = 1u;
	break;

	case eLED_STATUS_AZ_SENSOR_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO20 = 1u;
	break;

	case eLED_STATUS_AZ_SENSOR_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO86 = 1u;
	break;

	case eLED_STATUS_EL_BRAKE_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO21 = 1u;
	break;

	case eLED_STATUS_EL_BRAKE_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO87 = 1u;
	break;

	case eLED_STATUS_AZ_BRAKE_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO22 = 1u;
	break;

	case eLED_STATUS_AZ_BRAKE_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO88 = 1u;
	break;

	case eLED_STATUS_EL_LIMIT_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO23 = 1u;
	break;

	case eLED_STATUS_EL_LIMIT_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO89 = 1u;
	break;

	case eLED_STATUS_ML_LIMIT_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO24 = 1u;
	break;

	case eLED_STATUS_ML_LIMIT_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO91 = 1u;
	break;

	case eLED_STATUS_ANT_LOCK1_G:
		//GpioDataRegs.GPATOGGLE.bit.GPIO25 = 1u;
		GpioDataRegs.GPBDAT.bit.GPIO34 = 1u;
	break;

	case eLED_STATUS_ANT_LOCK1_R:
		//GpioDataRegs.GPCTOGGLE.bit.GPIO92 = 1u;
		GpioDataRegs.GPBDAT.bit.GPIO37 = 1u;
	break;

	case eLED_STATUS_ANT_LOCK2_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO26 = 1u;
	break;

	case eLED_STATUS_ANT_LOCK2_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO93 = 1u;
	break;

	case eLED_SETUP_DRIVING_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO10 = 1u;
	break;

	case eLED_SETUP_DRIVING_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO76 = 1u;
	break;

	case eLED_SETUP_DONE_G:
		GpioDataRegs.GPATOGGLE.bit.GPIO11 = 1u;
	break;

	case eLED_SETUP_DONE_R:
		GpioDataRegs.GPCTOGGLE.bit.GPIO77 = 1u;
	break;
	
	default:
		// MISRA
	break;
	}
}


#if 0 // 2025-08-05 16:13:32
/*
@funtion	static void setLed(stLed *pLed, Uint16 Color, Uint16 State)
@brief		
@param		[ stLed *pLed ]	
@param		[ Uint16 Color ]	
@param		[ Uint16 State ]	
@return		void
@remark	
	-	
*/
static void setLed(stLed *pLed, Uint16 Color, Uint16 State)
{
	if((pLed->Color != Color)
		|| (pLed->State != State))
	{
		if(Color == LED_GREEN)
		{
			// GREEN
			setLedEnable(pLed->IndexG, State);
			setLedEnable(pLed->IndexR, LED_OFF);
		}
		else
		{
			// RED
			setLedEnable(pLed->IndexG, LED_OFF);
			setLedEnable(pLed->IndexR, State);
		}

		pLed->Color = Color;
		pLed->State = State;
	}
}
#endif // #if 0 // 2025-08-05 16:13:32


